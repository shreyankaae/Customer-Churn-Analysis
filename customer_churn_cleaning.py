# -*- coding: utf-8 -*-
"""customer_churn_cleaning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n7nHk4r5rEaZto8iCNRLEeKv3icvzNGD
"""

!pip install shap xgboost scikit-learn pandas matplotlib seaborn joblib
!pip install ydata-profiling

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#EDA Report
from ydata_profiling import ProfileReport

# For model training
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

import pandas as pd

# Try basic load first
df = pd.read_csv("/content/Telco_customer_churn.csv")  # Replace with your actual filename

# If it still loads empty, try reading with additional options
df = pd.read_csv("/content/Telco_customer_churn.csv", encoding='utf-8', delimiter=',', skip_blank_lines=True)

print("Shape:", df.shape)
print("Columns:", df.columns.tolist())
df.head()

print("Shape of dataset:", df.shape)
print("Column names:\n", df.columns)
df.info()
df.describe()

df.isnull().sum()

"""# EDA

Univariate analysis
"""

sns.countplot(data=df, x='Churn', palette='pastel')
plt.title('Churn Distribution')
plt.show()

print(df['Churn'].value_counts(normalize=True))

sns.boxplot(x='churn_value', y='monthly_charges', palette='pastel', data=df)

"""This box plot compares **Monthly Charges** between two customer groups based on **Churn Value**:

* **Churn Value = 0**: Customers who did **not churn** (i.e., they stayed).
* **Churn Value = 1**: Customers who **churned** (i.e., they left the service).

### Observations:

#### 1. **Median Monthly Charges**:

* Churned customers (value = 1) have a **higher median** monthly charge (\~80) than non-churned customers (\~65).

#### 2. **Interquartile Range (IQR)**:

* **Non-churned (0)**: IQR is wider and skewed toward the lower end. This suggests more variability in charges for retained customers, especially on the lower side.
* **Churned (1)**: IQR is slightly narrower and shifted higher, indicating that most churned customers are paying more consistently in the higher range.

#### 3. **Outliers**:

* Both groups have a few outliers, but they appear to be similarly spread.

#### 4. **Minimum and Maximum**:

* Minimum and maximum charges are approximately the same for both groups, with minimum around 18–20 and maximum around 119–120.

---

### Conclusion:

* **Higher Monthly Charges** are associated with a higher **churn rate**.
* This suggests a potential opportunity to reduce churn by targeting high-paying customers with better service plans, discounts, or loyalty benefits.

Let me know if you’d like help generating this plot in code or including it in a report.

* `+1` → Perfect **positive** correlation (when one goes up, so does the other)
* `-1` → Perfect **negative** correlation (one goes up, the other goes down)
* `0` → No correlation

* **Color**:
  * **Redder** = stronger **positive** correlation
  * **Bluer** = stronger **negative** correlation
  * **White/light** = weaker or no correlation

## Key Insights:

### 1. **Churn Value & Churn Score (0.66)**:

* **Strong positive correlation** — high churn score is strongly associated with customers who actually churned.
*churn score is doing its job as a churn predictor.

### 2. **Churn Value & Tenure Months (-0.35)**:

* **Moderate negative correlation** — customers with **longer tenure** are **less likely to churn**.
* Action: Consider customer loyalty/retention programs for new users.

### 3. **Monthly Charges & Churn Value (0.19)**:

* **Weak positive correlation** — higher monthly charges slightly increase churn.
* Matches your boxplot insight.
* Action: Monitor high spenders for churn risk.


### 4. **CLTV & Tenure (0.4)**:

* **Moderate positive correlation** — longer tenure increases **Customer Lifetime Value**.
* Expected and good to know.

### 5. **Churn Score & Tenure (-0.22)**:

* Customers with shorter tenure tend to have higher churn scores — consistent with earlier findings.
"""

sns.histplot(df['tenure_months'], bins=30, kde=True, color='skyblue')
plt.title('Distribution of Tenure')
plt.show()

sns.countplot(data=df, x='contract', palette='Set2')
plt.title('Contract Type Distribution')
plt.xticks(rotation=45)
plt.show()

"""BIVERATE"""

sns.countplot(data=df, x='contract', hue='Churn', palette='Set2')
plt.title('Churn by Contract Type')
plt.xticks(rotation=45)
plt.show()

sns.boxplot(data=df, x='Churn', y='tenure_months', palette='coolwarm')
plt.title('Tenure vs Churn')
plt.show()

"""correlation matrix"""

plt.figure(figsize=(10, 6))
corr = df.corr(numeric_only=True)
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Matrix')
plt.show()

profile = ProfileReport(df, title='Telco Churn EDA Report', explorative=True)
profile.to_notebook_iframe()

"""# Data Cleaning

"""

df.drop('customer_id', axis=1, inplace=True)
# customerID is just an identifier; it has no predictive value.
# Machine learning models might overfit or misinterpret it if you leave it in the dataset, especially tree-based models like XGBoost.



cat_cols = df.select_dtypes(include='object').columns
for col in cat_cols:
    df[col].fillna(df[col].mode()[0], inplace=True)

# Fill numerical columns with median
num_cols = df.select_dtypes(include=['int64', 'float64']).columns
for col in num_cols:
    df[col].fillna(df[col].median(), inplace=True)

# ✅ Check again
print("Nulls after imputation:\n", df.isnull().sum().sum())  # should be 0
print("Final shape after cleaning:", df.shape)

df.isnull().sum()

print(df.shape)

df['Churn'] = df['Churn'].map({'Yes': 1, 'No': 0})

df.to_csv('cleaned_telco.csv', index=False)





from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_encoded)